(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{148:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return o})),a.d(t,"toc",(function(){return l})),a.d(t,"default",(function(){return p}));var n=a(3),s=a(7),r=(a(0),a(259)),i={title:"OSC",id:"osc",permalink:"wiki/MIDI/",layout:"wiki"},o={unversionedId:"configuration/MIDIOSC/osc",id:"configuration/MIDIOSC/osc",isDocsHomePage:!1,title:"OSC",description:"Open Sound Control (OSC) is a standard network protocol, ostensibly designed for music, but it's really just an easy way to send numbers and other data across a network. A range of live coding and other systems including DAWs (Digital Audio Workstations), visualisers and mixers are compatible with OSC.",source:"@site/docs/configuration/MIDIOSC/OSC.md",slug:"/configuration/MIDIOSC/osc",permalink:"/docs/configuration/MIDIOSC/osc",editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/configuration/MIDIOSC/OSC.md",version:"current",lastUpdatedBy:"Raphael Forment",lastUpdatedAt:1621614610,sidebar:"docs",previous:{title:"MIDI",permalink:"/docs/configuration/MIDIOSC/midi"},next:{title:"DAW",permalink:"/docs/configuration/MIDIOSC/connecting_to_a_daw"}},l=[{value:"Extensive Tutorial",id:"extensive-tutorial",children:[{value:"Defining a Target",id:"defining-a-target",children:[]},{value:"Defining OSC message structure",id:"defining-osc-message-structure",children:[]},{value:"Named parameters",id:"named-parameters",children:[]},{value:"Defining additional parameters",id:"defining-additional-parameters",children:[]},{value:"Mapping message structures to targets",id:"mapping-message-structures-to-targets",children:[]},{value:"Starting and sending patterns to the stream",id:"starting-and-sending-patterns-to-the-stream",children:[]},{value:"Shortcuts",id:"shortcuts",children:[]},{value:"Recap",id:"recap",children:[]},{value:"Multiple targets and messages",id:"multiple-targets-and-messages",children:[]},{value:"Complex targets with multiple message formats",id:"complex-targets-with-multiple-message-formats",children:[]}]},{value:"Debugging",id:"debugging",children:[]}],c={toc:l};function p(e){var t=e.components,a=Object(s.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Open Sound Control (OSC)")," is a standard network protocol, ostensibly designed for music, but it's really just an easy way to send numbers and other data across a network. A range of live coding and other systems including DAWs (Digital Audio Workstations), visualisers and mixers are compatible with OSC."),Object(r.b)("p",null,"Really the one and only job of Tidal Cycles is to send patterned OSC messages, most often to the ",Object(r.b)("strong",{parentName:"p"},"SuperDirt")," audio framework. It's fairly straightforward to configure ",Object(r.b)("strong",{parentName:"p"},"Tidal")," to send OSC to another system. It involves specifying where messages should be sent to (the target) - and the structure of the OSC data that is sent (the shape or format of the message)."),Object(r.b)("h2",{id:"extensive-tutorial"},"Extensive Tutorial"),Object(r.b)("h3",{id:"defining-a-target"},"Defining a Target"),Object(r.b)("p",null,"First, define a target:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let target =\n      Target {oName = "visualiser",   -- A friendly name for the target (only used in error messages)\n              oAddress = "localhost", -- The target\'s network address, normally "localhost"\n              oPort = 5050,           -- The network port the target is listening on\n              oLatency = 0.2,         -- Additional delay, to smooth out network jitter/get things in sync\n              oSchedule = Live,       -- The scheduling method - see below\n              oWindow = Nothing,      -- Not yet used\n              oHandshake = False,     -- SuperDirt specific\n              oBusPort = Nothing      -- Also SuperDirt specific\n             }\n')),Object(r.b)("p",null,"The scheduling method for oSchedule can be one of:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Live"),": causes Tidal to schedule messages so that they are sent out at the 'right' time, minus the ",Object(r.b)("inlineCode",{parentName:"p"},"oLatency")," value. This is the simplest approach, that will work well in most cases.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Pre BundleStamp"),": sends each OSC message wrapped in an OSC 'bundle' with a bundle timestamp. The bundled messages will be sent out once per frame in batches, but ahead of time (according to the ",Object(r.b)("inlineCode",{parentName:"p"},"oLatency")," configuration value). Tidal doesn't attempt to send them out with 'correct' timing, instead the target is expected schedule them accurately. This is more work for the target, but is potentially more accurate than the above, as potential network/processing jitter can be avoided.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("strong",{parentName:"p"},"Pre MessageStamp"),": as with ",Object(r.b)("inlineCode",{parentName:"p"},"BundleStamp"),' above, but the timestamp is added to the OSC message itself, filling in the two integer fields "sec" and "usec". You have to explicitly include these in the argument list of your osc format (see later for an example).'))),Object(r.b)("h3",{id:"defining-osc-message-structure"},"Defining OSC message structure"),Object(r.b)("p",null,"Next, define the structure of the OSC message. It's worth first spending a bit of time familiarising yourself with the OSC spec. There are two ways to structure the OSC messages that Tidal sends. Either as an argument list, or as name-value pairs."),Object(r.b)("p",null,"The argument list approach is most common. It looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let oscplay = OSC "/play" $ ArgList [("s", Nothing),\n                                     ("vowel", Just $ VS "a"),\n                                     ("pan", Just $ VF 0.5),\n                                     ("cut", Just $ VI 1),\n                                     ("intensity", Just $ VI 0)\n                                   ]\n')),Object(r.b)("p",null,'To define the OSC structure, you start with OSC, followed by the OSC "address pattern", in this case ',Object(r.b)("inlineCode",{parentName:"p"},'"/play"'),". Then you list the message arguments, in order. Each argument is given as a 'tuple', containing the name of the parameter, and its default value."),Object(r.b)("p",null,"In the above example, the first parameter called ",Object(r.b)("inlineCode",{parentName:"p"},'"s"')," doesn't have a default, indicated by the keyword ",Object(r.b)("inlineCode",{parentName:"p"},"Nothing"),". This means that if no s parameter is given by a pattern, no OSC message will be sent."),Object(r.b)("p",null,"The other arguments in the example have defaults indicated by the keyword ",Object(r.b)("inlineCode",{parentName:"p"},"Just"),", followed by the type of the argument and its default value. ",Object(r.b)("inlineCode",{parentName:"p"},"VS")," gives a default as a string, ",Object(r.b)("inlineCode",{parentName:"p"},"VF")," as a floating point number, and ",Object(r.b)("inlineCode",{parentName:"p"},"VI")," as an integer. Other available types are ",Object(r.b)("inlineCode",{parentName:"p"},"VB")," for true/false boolean values (which are converted to 1 / 0 integer values in the message) and ",Object(r.b)("inlineCode",{parentName:"p"},"VX")," for binary 'blobs'. If one or more of these arguments-with-defaults aren't present in a pattern, the message will still be sent with these default values."),Object(r.b)("p",null,"If you are using ",Object(r.b)("strong",{parentName:"p"},"Pre MessageStamp"),", you will need to add the ",Object(r.b)("inlineCode",{parentName:"p"},"sec")," and ",Object(r.b)("inlineCode",{parentName:"p"},"usec")," message parameters in order for them to be sent:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let oscplay = OSC "/play" $ ArgList [("s", Nothing),\n                                     ("vowel", Just $ VS "a"),\n                                     ("pan", Just $ VF 0.5),\n                                     ("cut", Just $ VI 1),\n                                     ("intensity", Just $ VI 0),\n                                     ("sec", Just $ VF 0),\n                                     ("usec", Just $ VF 0)\n                                   ]\n')),Object(r.b)("p",null,"As well as ",Object(r.b)("inlineCode",{parentName:"p"},"sec")," and ",Object(r.b)("inlineCode",{parentName:"p"},"usec"),", there are three other parameters that Tidal will always fill in if present; ",Object(r.b)("inlineCode",{parentName:"p"},"cps")," (cycles per second), ",Object(r.b)("inlineCode",{parentName:"p"},"cycle")," (the start of the event in cycles) and ",Object(r.b)("inlineCode",{parentName:"p"},"delta")," (the duration of the event in cycles). So add those too, if you want that information to be sent to the target:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let oscplay = OSC "/play" $ ArgList [("s", Nothing),\n                                     ("vowel", Just $ VS "a"),\n                                     ("pan", Just $ VF 0.5),\n                                     ("cut", Just $ VI 1),\n                                     ("intensity", Just $ VI 0),\n                                     ("sec", Just $ VF 0),\n                                     ("usec", Just $ VF 0),\n                                     ("cps", Just $ VF 0),\n                                     ("cycle", Just $ VF 0),\n                                     ("delta", Just $ VF 0)\n                                   ]\n')),Object(r.b)("h3",{id:"named-parameters"},"Named parameters"),Object(r.b)("p",null,"Instead of giving an argument list as above, you can specify named parameters like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let oscplay = OSC "/play" Named {required = ["s"]}\n')),Object(r.b)("p",null,"With such a definition, all parameters in a pattern will be sent to the target. Instead of having fixed positions in a message as with an argument list, the parameters will be in an arbitrary order, but as name-value pairs. That is, each parameter will be prefixed by an additional string parameter, giving its name. As you can see in the example, a list of 'required' parameters is given - unless all of the parameters named in this list are present in an patterned event, it will not be sent."),Object(r.b)("h3",{id:"defining-additional-parameters"},"Defining additional parameters"),Object(r.b)("p",null,"Many parameters are defined in ",Object(r.b)("inlineCode",{parentName:"p"},"Sound.Tidal.Params"),", and available to a Tidal session. If you want to send parameters which aren't already defined, you can define them yourself. For example ",Object(r.b)("inlineCode",{parentName:"p"},"'intensity'")," used above needs to be defined, like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let intensity = pF "intensity"\n')),Object(r.b)("h3",{id:"mapping-message-structures-to-targets"},"Mapping message structures to targets"),Object(r.b)("p",null,"The final thing that needs defining, is a mapping between targets and the OSC message structures they accept. In this case there's only one target that accepts a single kind of OSC message, so it's simple:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"let oscmap = [(target, [oscplay])]\n")),Object(r.b)("h3",{id:"starting-and-sending-patterns-to-the-stream"},"Starting and sending patterns to the stream"),Object(r.b)("p",null,"Then you can start a ",Object(r.b)("inlineCode",{parentName:"p"},"'stream'")," for turning patterns into OSC like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"stream <- startStream defaultConfig oscmap\n")),Object(r.b)("p",null,"And start sending a pattern like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'streamReplace stream 1 $ s "hello" # cut 1 # intensity 3\n')),Object(r.b)("h3",{id:"shortcuts"},"Shortcuts"),Object(r.b)("p",null,"You can define some shortcuts like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"let x1 = streamReplace stream 1\n    x2 = streamReplace stream 2\n    x3 = streamReplace stream 3\n    x4 = streamReplace stream 4\n")),Object(r.b)("p",null,"Then this will work:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'x1 $ s "hello" # cut 1 # intensity 3\n')),Object(r.b)("p",null,"This is much like how ",Object(r.b)("inlineCode",{parentName:"p"},"d1"),", ",Object(r.b)("inlineCode",{parentName:"p"},"d2"),", etc... are defined in ",Object(r.b)("inlineCode",{parentName:"p"},"BootTidal.hs"),". Refer to the the default ",Object(r.b)("inlineCode",{parentName:"p"},"BootTidal.hs")," file (look at the sidebar) to see how the other tidal functions are normally defined."),Object(r.b)("h3",{id:"recap"},"Recap"),Object(r.b)("p",null,"Here's all that code together:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let target =\n      Target {oName = "visualiser",   -- A friendly name for the target (only used in error messages)\n              oAddress = "localhost", -- The target\'s network address, normally "localhost"\n              oPort = 5050,           -- The network port the target is listening on\n              oLatency = 0.2,         -- Additional delay, to smooth out network jitter/get things in sync\n              oSchedule = Live,       -- The scheduling method - see below\n              oWindow = Nothing,      -- Not yet used\n              oHandshake = False,     -- SuperDirt specific\n              oBusPort = Nothing      -- Also SuperDirt specific\n             }\n    oscplay = OSC "/play" $ ArgList [("s", Nothing),\n                                     ("vowel", Just $ VS "a"),\n                                     ("pan", Just $ VF 0.5),\n                                     ("volume", Just $ VF 1),\n                                     ("cut", Just $ VI 1),\n                                     ("intensity", Just $ VI 0)\n                                   ]\n    intensity = pF "intensity"\n    oscmap = [(target, [oscplay])]\n\n\nstream <- startStream defaultConfig oscmap\n\nlet x1 = streamReplace stream 1\n    x2 = streamReplace stream 2\n    x3 = streamReplace stream 3\n    x4 = streamReplace stream 4\n')),Object(r.b)("h3",{id:"multiple-targets-and-messages"},"Multiple targets and messages"),Object(r.b)("p",null,"It's possible to pattern multiple OSC messages and send them to multiple targets, from the same ",Object(r.b)("inlineCode",{parentName:"p"},"'stream'"),". For example to make a stream that sends both to the above target and to ",Object(r.b)("strong",{parentName:"p"},"SuperDirt"),", you could do this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let oscmap = [(target, [oscplay]),\n              (superdirtTarget, [superdirtShape])\n             ]\n\nstream <- startStream defaultConfig oscmap\n\nd = streamReplace stream\n\nd 1 $ s "bd"\n')),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"bd")," above will be sent to both ",Object(r.b)("inlineCode",{parentName:"p"},"target")," and ",Object(r.b)("inlineCode",{parentName:"p"},"superdirtTarget"),"."),Object(r.b)("h3",{id:"complex-targets-with-multiple-message-formats"},"Complex targets with multiple message formats"),Object(r.b)("p",null,"Some OSC targets are more complicated, accept multiple OSC formats and also specifying data in the osc 'address pattern'. Lets take the ASCII-Simple-Video-Synth as an example. Here's the Tidal specification for it:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let target = Target {oName = "ascii",\n                     oAddress = "127.0.0.1",\n                     oPort = 5050,\n                     oLatency = 0.2,\n                     oWindow = Nothing,\n                     oSchedule = Live,\n                     oHandshake = False,\n                     oBusPort = Nothing \n                    }\n    formats = [OSC "/{asccolour}/speed"  $ ArgList [("ascspeed", Nothing)],\n               OSC "/{asccolour}/mode"   $ ArgList [("ascmode", Nothing)],\n               OSC "/{asccolour}/offset" $ ArgList [("ascoffset", Nothing)],\n               OSC "/{asccolour}/scale"  $ ArgList [("ascscale", Nothing)],\n               OSC "/shape/sides" $ ArgList [("ascsides", Nothing)],\n               OSC "/shape/size"  $ ArgList [("ascsize", Nothing)],\n               OSC "/shape/xinc"  $ ArgList [("ascxinc", Nothing)],\n               OSC "/shape/yinc"  $ ArgList [("ascyinc", Nothing)]\n              ]\n    ascspeed  = pI "ascspeed"\n    ascmode   = pI "ascmode"\n    ascoffset = pI "ascoffset"\n    ascscale  = pI "ascscale"\n    ascsides  = pI "ascsides"\n    ascsize   = pI "ascsize"\n    ascxinc   = pI "ascxinc"\n    ascyinc   = pI "ascyinc"\n    asccolour = pS "asccolour"\n    oscmap = [(target, formats)]\n\nstream <- startStream defaultConfig oscmap\n\nstreamReplace stream 1 $ asccolour "blue green red"\n  # ascspeed "38 15"\n  # ascsides 3\n  # ascoffset 10\n  # ascxinc 10\n  # ascyinc 10\n  # ascmode 0\n  # ascsize 30\n')),Object(r.b)("p",null,"This software accepts a number of address patterns, some of which include the colour which is being addressed. To make this colour patternable, it is given a name in curly braces, ",Object(r.b)("inlineCode",{parentName:"p"},'"{asccolour}"'),". This is then patternable with the ",Object(r.b)("inlineCode",{parentName:"p"},"'ascColour'")," parameter in the Tidal pattern."),Object(r.b)("p",null,"When you assign multiple OSC message formats to a stream, it's a good idea to make sure that every format has at least one unique, non-default argument. This ensures that messages will only be sent when the non-default arguments are set in the pattern. Otherwise, all the formats will be sent for every patterned event."),Object(r.b)("h2",{id:"debugging"},"Debugging"),Object(r.b)("p",null,"One way to debug OSC is to use a packet sniffer like ",Object(r.b)("a",{parentName:"p",href:"https://www.wireshark.org/"},"WireShark"),". You can put ",Object(r.b)("inlineCode",{parentName:"p"},"osc")," in the filter field to filter out everything except OSC packets. If you click on an ",Object(r.b)("inlineCode",{parentName:"p"},"OSC network packet")," and expand fields you can find a nicely formatted representation of your OSC message. "))}p.isMDXComponent=!0},259:function(e,t,a){"use strict";a.d(t,"a",(function(){return d})),a.d(t,"b",(function(){return b}));var n=a(0),s=a.n(n);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var c=s.a.createContext({}),p=function(e){var t=s.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=p(e.components);return s.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},m=s.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(a),m=n,b=d["".concat(i,".").concat(m)]||d[m]||u[m]||r;return a?s.a.createElement(b,o(o({ref:t},c),{},{components:a})):s.a.createElement(b,o({ref:t},c))}));function b(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var c=2;c<r;c++)i[c]=a[c];return s.a.createElement.apply(null,i)}return s.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);